//
// Copyright (c) 2018 Stegos
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! Leader election algorithms and tests.

use log::error;
use stegos_crypto::hash::Hash;
/// Choose random validator, based on `random_number`.
/// Accepts list of validators stakes consistently sorted on all participants,
/// And `random_number` generated by randhound.
/// Returns index of the validator which stake are won.
pub fn elect_new_leader<'a, I>(validators: I, random_number: i64) -> Option<usize>
where
    I: IntoIterator<Item = &'a i64>,
    // We need multiples passes to process the `Iterator`.
    // One for summing the stake, second for getting the winner.
    <I as IntoIterator>::IntoIter: Clone,
{
    let validators = validators.into_iter();

    let sum_stakes: i64 = validators.clone().sum();
    if sum_stakes == 0 {
        error!("Nobody place a stack, we can't choose a leader.");
        return None;
    }

    let need_stake = random_number % sum_stakes;

    let mut accumulator: i64 = 0;
    for (num, validator_stake) in validators.enumerate() {
        assert!(
            *validator_stake >= 0,
            "Processing invalid validator stake < 0."
        );
        if accumulator + validator_stake > need_stake {
            return Some(num);
        }
        accumulator += validator_stake;
    }
    unreachable!("Validator should be found in loop.")
}

/// Returns small u64 value that will be used for choosing a leader.
pub fn shrink_random(big_random: Hash) -> i64 {
    let big_random = big_random.base_vector();
    let small = (big_random[0] as i64) << 0
        | (big_random[1] as i64) << 8
        | (big_random[2] as i64) << 16
        | (big_random[3] as i64) << 24
        | (big_random[4] as i64) << 32
        | (big_random[5] as i64) << 40
        | (big_random[6] as i64) << 48
        | (big_random[7] as i64) << 56;
    small.checked_abs().unwrap_or(0)
}

#[cfg(test)]
mod test {
    use super::elect_new_leader;
    use std::collections::{HashMap, HashSet};

    fn broken_random(nums: i64) -> impl Iterator<Item = i64> {
        (0..nums).into_iter()
    }

    /// If no one nodes found, nobody could be an leader.
    #[test]
    fn test_empty_validators() {
        let validators = vec![];

        assert!(elect_new_leader(&validators, 0).is_none());
        assert!(elect_new_leader(&validators, 2).is_none());
        assert!(elect_new_leader(&validators, 5).is_none());
    }

    /// If all nodes didn't give any stakes algorithm should return None.
    #[test]
    fn test_empty_stakes() {
        let validators = vec![0, 0, 0, 0];
        // init 4 validators stakes

        assert!(elect_new_leader(&validators, 0).is_none());
        assert!(elect_new_leader(&validators, 2).is_none());
        assert!(elect_new_leader(&validators, 5).is_none());
    }

    /// If only one man give a stake, make them new leader.
    #[test]
    fn test_only_one_rich() {
        let validators = vec![1, 0, 0, 0];

        assert_eq!(elect_new_leader(&validators, 0), Some(0));
        assert_eq!(elect_new_leader(&validators, 2), Some(0));
        assert_eq!(elect_new_leader(&validators, 5), Some(0));
    }

    /// All validators should can be a leader.
    #[test]
    fn test_all_validators() {
        let validators = vec![1, 2, 3, 4];

        let mut leaders = HashSet::new();

        let random = broken_random(validators.len() as i64 * 50);

        for leader in random {
            leaders.insert(elect_new_leader(&validators, leader).unwrap());
        }
        assert_eq!(leaders.len(), validators.len())
    }

    /// With same stake probability should be the same
    /// .
    #[test]
    fn test_probability_simple() {
        let validators = vec![1, 1, 1, 1];

        let mut leaders = HashMap::new();

        let random = broken_random(validators.len() as i64 * 50);

        for leader in random {
            *leaders
                .entry(elect_new_leader(&validators, leader).unwrap())
                .or_insert(0) += 1;
        }

        assert_eq!(leaders[&0], leaders[&1]);
        assert_eq!(leaders[&1], leaders[&2]);
        assert_eq!(leaders[&2], leaders[&3]);
    }

    /// Probability of leader should be the same as it's stake.
    #[test]
    fn test_probability_complex() {
        let validators = vec![1, 2, 3, 4];

        let mut leaders = HashMap::new();

        let random = broken_random(validators.len() as i64 * 10);

        for leader in random {
            *leaders
                .entry(elect_new_leader(&validators, leader).unwrap())
                .or_insert(0) += 1;
        }

        assert!(leaders[&3] == leaders[&0] * 4);
        assert_eq!(leaders[&2], leaders[&0] * 3);
        assert_eq!(leaders[&1], leaders[&0] * 2);
    }

}
