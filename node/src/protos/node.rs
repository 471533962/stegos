// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Pt {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Pt {
    pub fn new() -> Pt {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Pt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pt {
        Pt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Pt| { &m.data },
                    |m: &mut Pt| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pt>(
                    "Pt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pt {
        static mut instance: ::protobuf::lazy::Lazy<Pt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pt,
        };
        unsafe {
            instance.get(Pt::new)
        }
    }
}

impl ::protobuf::Clear for Pt {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Fr {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Fr {
    pub fn new() -> Fr {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Fr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Fr {
        Fr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Fr| { &m.data },
                    |m: &mut Fr| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Fr>(
                    "Fr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Fr {
        static mut instance: ::protobuf::lazy::Lazy<Fr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Fr,
        };
        unsafe {
            instance.get(Fr::new)
        }
    }
}

impl ::protobuf::Clear for Fr {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Fr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct G2 {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl G2 {
    pub fn new() -> G2 {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for G2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> G2 {
        G2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &G2| { &m.data },
                    |m: &mut G2| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<G2>(
                    "G2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static G2 {
        static mut instance: ::protobuf::lazy::Lazy<G2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const G2,
        };
        unsafe {
            instance.get(G2::new)
        }
    }
}

impl ::protobuf::Clear for G2 {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for G2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for G2 {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hash {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Hash| { &m.data },
                    |m: &mut Hash| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hash>(
                    "Hash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hash {
        static mut instance: ::protobuf::lazy::Lazy<Hash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hash,
        };
        unsafe {
            instance.get(Hash::new)
        }
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublicKey {
    // message fields
    pub point: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt point = 1;

    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: Pt) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut Pt {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> Pt {
        self.point.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_point(&self) -> &Pt {
        self.point.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for PublicKey {
    fn is_initialized(&self) -> bool {
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "point",
                    |m: &PublicKey| { &m.point },
                    |m: &mut PublicKey| { &mut m.point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublicKey>(
                    "PublicKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublicKey {
        static mut instance: ::protobuf::lazy::Lazy<PublicKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublicKey,
        };
        unsafe {
            instance.get(PublicKey::new)
        }
    }
}

impl ::protobuf::Clear for PublicKey {
    fn clear(&mut self) {
        self.clear_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchnorrSig {
    // message fields
    pub u: ::protobuf::SingularPtrField<Fr>,
    pub K: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SchnorrSig {
    pub fn new() -> SchnorrSig {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Fr u = 1;

    pub fn clear_u(&mut self) {
        self.u.clear();
    }

    pub fn has_u(&self) -> bool {
        self.u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u(&mut self, v: Fr) {
        self.u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u(&mut self) -> &mut Fr {
        if self.u.is_none() {
            self.u.set_default();
        }
        self.u.as_mut().unwrap()
    }

    // Take field
    pub fn take_u(&mut self) -> Fr {
        self.u.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_u(&self) -> &Fr {
        self.u.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Pt K = 2;

    pub fn clear_K(&mut self) {
        self.K.clear();
    }

    pub fn has_K(&self) -> bool {
        self.K.is_some()
    }

    // Param is passed by value, moved
    pub fn set_K(&mut self, v: Pt) {
        self.K = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_K(&mut self) -> &mut Pt {
        if self.K.is_none() {
            self.K.set_default();
        }
        self.K.as_mut().unwrap()
    }

    // Take field
    pub fn take_K(&mut self) -> Pt {
        self.K.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_K(&self) -> &Pt {
        self.K.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for SchnorrSig {
    fn is_initialized(&self) -> bool {
        for v in &self.u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.K {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.u)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.K)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.K.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.u.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.K.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchnorrSig {
        SchnorrSig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "u",
                    |m: &SchnorrSig| { &m.u },
                    |m: &mut SchnorrSig| { &mut m.u },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "K",
                    |m: &SchnorrSig| { &m.K },
                    |m: &mut SchnorrSig| { &mut m.K },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SchnorrSig>(
                    "SchnorrSig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SchnorrSig {
        static mut instance: ::protobuf::lazy::Lazy<SchnorrSig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SchnorrSig,
        };
        unsafe {
            instance.get(SchnorrSig::new)
        }
    }
}

impl ::protobuf::Clear for SchnorrSig {
    fn clear(&mut self) {
        self.clear_u();
        self.clear_K();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchnorrSig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchnorrSig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurePublicKey {
    // message fields
    pub point: ::protobuf::SingularPtrField<G2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SecurePublicKey {
    pub fn new() -> SecurePublicKey {
        ::std::default::Default::default()
    }

    // .protobuf.pb.G2 point = 1;

    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: G2) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut G2 {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> G2 {
        self.point.take().unwrap_or_else(|| G2::new())
    }

    pub fn get_point(&self) -> &G2 {
        self.point.as_ref().unwrap_or_else(|| G2::default_instance())
    }
}

impl ::protobuf::Message for SecurePublicKey {
    fn is_initialized(&self) -> bool {
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecurePublicKey {
        SecurePublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<G2>>(
                    "point",
                    |m: &SecurePublicKey| { &m.point },
                    |m: &mut SecurePublicKey| { &mut m.point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SecurePublicKey>(
                    "SecurePublicKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SecurePublicKey {
        static mut instance: ::protobuf::lazy::Lazy<SecurePublicKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SecurePublicKey,
        };
        unsafe {
            instance.get(SecurePublicKey::new)
        }
    }
}

impl ::protobuf::Clear for SecurePublicKey {
    fn clear(&mut self) {
        self.clear_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurePublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurePublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptedPayload {
    // message fields
    pub apkg: ::protobuf::SingularPtrField<Pt>,
    pub ag: ::protobuf::SingularPtrField<Pt>,
    pub ctxt: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncryptedPayload {
    pub fn new() -> EncryptedPayload {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt apkg = 1;

    pub fn clear_apkg(&mut self) {
        self.apkg.clear();
    }

    pub fn has_apkg(&self) -> bool {
        self.apkg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apkg(&mut self, v: Pt) {
        self.apkg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apkg(&mut self) -> &mut Pt {
        if self.apkg.is_none() {
            self.apkg.set_default();
        }
        self.apkg.as_mut().unwrap()
    }

    // Take field
    pub fn take_apkg(&mut self) -> Pt {
        self.apkg.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_apkg(&self) -> &Pt {
        self.apkg.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt ag = 2;

    pub fn clear_ag(&mut self) {
        self.ag.clear();
    }

    pub fn has_ag(&self) -> bool {
        self.ag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ag(&mut self, v: Pt) {
        self.ag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ag(&mut self) -> &mut Pt {
        if self.ag.is_none() {
            self.ag.set_default();
        }
        self.ag.as_mut().unwrap()
    }

    // Take field
    pub fn take_ag(&mut self) -> Pt {
        self.ag.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_ag(&self) -> &Pt {
        self.ag.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // bytes ctxt = 3;

    pub fn clear_ctxt(&mut self) {
        self.ctxt.clear();
    }

    // Param is passed by value, moved
    pub fn set_ctxt(&mut self, v: ::std::vec::Vec<u8>) {
        self.ctxt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ctxt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ctxt
    }

    // Take field
    pub fn take_ctxt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ctxt, ::std::vec::Vec::new())
    }

    pub fn get_ctxt(&self) -> &[u8] {
        &self.ctxt
    }
}

impl ::protobuf::Message for EncryptedPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.apkg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apkg)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ctxt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apkg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ctxt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ctxt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apkg.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ag.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ctxt.is_empty() {
            os.write_bytes(3, &self.ctxt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedPayload {
        EncryptedPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "apkg",
                    |m: &EncryptedPayload| { &m.apkg },
                    |m: &mut EncryptedPayload| { &mut m.apkg },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "ag",
                    |m: &EncryptedPayload| { &m.ag },
                    |m: &mut EncryptedPayload| { &mut m.ag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ctxt",
                    |m: &EncryptedPayload| { &m.ctxt },
                    |m: &mut EncryptedPayload| { &mut m.ctxt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncryptedPayload>(
                    "EncryptedPayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptedPayload {
        static mut instance: ::protobuf::lazy::Lazy<EncryptedPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncryptedPayload,
        };
        unsafe {
            instance.get(EncryptedPayload::new)
        }
    }
}

impl ::protobuf::Clear for EncryptedPayload {
    fn clear(&mut self) {
        self.clear_apkg();
        self.clear_ag();
        self.clear_ctxt();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LR {
    // message fields
    pub x: ::protobuf::SingularPtrField<Fr>,
    pub l: ::protobuf::SingularPtrField<Pt>,
    pub r: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LR {
    pub fn new() -> LR {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Fr x = 1;

    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Fr) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Fr {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Fr {
        self.x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_x(&self) -> &Fr {
        self.x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Pt l = 2;

    pub fn clear_l(&mut self) {
        self.l.clear();
    }

    pub fn has_l(&self) -> bool {
        self.l.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l(&mut self, v: Pt) {
        self.l = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_l(&mut self) -> &mut Pt {
        if self.l.is_none() {
            self.l.set_default();
        }
        self.l.as_mut().unwrap()
    }

    // Take field
    pub fn take_l(&mut self) -> Pt {
        self.l.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_l(&self) -> &Pt {
        self.l.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt r = 3;

    pub fn clear_r(&mut self) {
        self.r.clear();
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: Pt) {
        self.r = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r(&mut self) -> &mut Pt {
        if self.r.is_none() {
            self.r.set_default();
        }
        self.r.as_mut().unwrap()
    }

    // Take field
    pub fn take_r(&mut self) -> Pt {
        self.r.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_r(&self) -> &Pt {
        self.r.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for LR {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.l {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.r {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.l)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.r)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.l.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.l.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.r.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LR {
        LR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "x",
                    |m: &LR| { &m.x },
                    |m: &mut LR| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "l",
                    |m: &LR| { &m.l },
                    |m: &mut LR| { &mut m.l },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "r",
                    |m: &LR| { &m.r },
                    |m: &mut LR| { &mut m.r },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LR>(
                    "LR",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LR {
        static mut instance: ::protobuf::lazy::Lazy<LR> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LR,
        };
        unsafe {
            instance.get(LR::new)
        }
    }
}

impl ::protobuf::Clear for LR {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_l();
        self.clear_r();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LR {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DotProof {
    // message fields
    pub u: ::protobuf::SingularPtrField<Pt>,
    pub pcmt: ::protobuf::SingularPtrField<Pt>,
    pub a: ::protobuf::SingularPtrField<Fr>,
    pub b: ::protobuf::SingularPtrField<Fr>,
    pub xlrs: ::protobuf::RepeatedField<LR>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DotProof {
    pub fn new() -> DotProof {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt u = 1;

    pub fn clear_u(&mut self) {
        self.u.clear();
    }

    pub fn has_u(&self) -> bool {
        self.u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u(&mut self, v: Pt) {
        self.u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u(&mut self) -> &mut Pt {
        if self.u.is_none() {
            self.u.set_default();
        }
        self.u.as_mut().unwrap()
    }

    // Take field
    pub fn take_u(&mut self) -> Pt {
        self.u.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_u(&self) -> &Pt {
        self.u.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt pcmt = 2;

    pub fn clear_pcmt(&mut self) {
        self.pcmt.clear();
    }

    pub fn has_pcmt(&self) -> bool {
        self.pcmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pcmt(&mut self, v: Pt) {
        self.pcmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pcmt(&mut self) -> &mut Pt {
        if self.pcmt.is_none() {
            self.pcmt.set_default();
        }
        self.pcmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_pcmt(&mut self) -> Pt {
        self.pcmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_pcmt(&self) -> &Pt {
        self.pcmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Fr a = 3;

    pub fn clear_a(&mut self) {
        self.a.clear();
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: Fr) {
        self.a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_a(&mut self) -> &mut Fr {
        if self.a.is_none() {
            self.a.set_default();
        }
        self.a.as_mut().unwrap()
    }

    // Take field
    pub fn take_a(&mut self) -> Fr {
        self.a.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_a(&self) -> &Fr {
        self.a.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr b = 4;

    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: Fr) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut Fr {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> Fr {
        self.b.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_b(&self) -> &Fr {
        self.b.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // repeated .protobuf.pb.LR xlrs = 5;

    pub fn clear_xlrs(&mut self) {
        self.xlrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_xlrs(&mut self, v: ::protobuf::RepeatedField<LR>) {
        self.xlrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xlrs(&mut self) -> &mut ::protobuf::RepeatedField<LR> {
        &mut self.xlrs
    }

    // Take field
    pub fn take_xlrs(&mut self) -> ::protobuf::RepeatedField<LR> {
        ::std::mem::replace(&mut self.xlrs, ::protobuf::RepeatedField::new())
    }

    pub fn get_xlrs(&self) -> &[LR] {
        &self.xlrs
    }
}

impl ::protobuf::Message for DotProof {
    fn is_initialized(&self) -> bool {
        for v in &self.u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pcmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.a {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xlrs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.u)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pcmt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.a)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xlrs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pcmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.xlrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.u.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pcmt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.a.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.xlrs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DotProof {
        DotProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "u",
                    |m: &DotProof| { &m.u },
                    |m: &mut DotProof| { &mut m.u },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "pcmt",
                    |m: &DotProof| { &m.pcmt },
                    |m: &mut DotProof| { &mut m.pcmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "a",
                    |m: &DotProof| { &m.a },
                    |m: &mut DotProof| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "b",
                    |m: &DotProof| { &m.b },
                    |m: &mut DotProof| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LR>>(
                    "xlrs",
                    |m: &DotProof| { &m.xlrs },
                    |m: &mut DotProof| { &mut m.xlrs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DotProof>(
                    "DotProof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DotProof {
        static mut instance: ::protobuf::lazy::Lazy<DotProof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DotProof,
        };
        unsafe {
            instance.get(DotProof::new)
        }
    }
}

impl ::protobuf::Clear for DotProof {
    fn clear(&mut self) {
        self.clear_u();
        self.clear_pcmt();
        self.clear_a();
        self.clear_b();
        self.clear_xlrs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DotProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DotProof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BulletProof {
    // message fields
    pub vcmt: ::protobuf::SingularPtrField<Pt>,
    pub acmt: ::protobuf::SingularPtrField<Pt>,
    pub scmt: ::protobuf::SingularPtrField<Pt>,
    pub t1_cmt: ::protobuf::SingularPtrField<Pt>,
    pub t2_cmt: ::protobuf::SingularPtrField<Pt>,
    pub tau_x: ::protobuf::SingularPtrField<Fr>,
    pub mu: ::protobuf::SingularPtrField<Fr>,
    pub t_hat: ::protobuf::SingularPtrField<Fr>,
    pub dot_proof: ::protobuf::SingularPtrField<DotProof>,
    pub x: ::protobuf::SingularPtrField<Fr>,
    pub y: ::protobuf::SingularPtrField<Fr>,
    pub z: ::protobuf::SingularPtrField<Fr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BulletProof {
    pub fn new() -> BulletProof {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt vcmt = 1;

    pub fn clear_vcmt(&mut self) {
        self.vcmt.clear();
    }

    pub fn has_vcmt(&self) -> bool {
        self.vcmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vcmt(&mut self, v: Pt) {
        self.vcmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vcmt(&mut self) -> &mut Pt {
        if self.vcmt.is_none() {
            self.vcmt.set_default();
        }
        self.vcmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_vcmt(&mut self) -> Pt {
        self.vcmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_vcmt(&self) -> &Pt {
        self.vcmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt acmt = 2;

    pub fn clear_acmt(&mut self) {
        self.acmt.clear();
    }

    pub fn has_acmt(&self) -> bool {
        self.acmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acmt(&mut self, v: Pt) {
        self.acmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acmt(&mut self) -> &mut Pt {
        if self.acmt.is_none() {
            self.acmt.set_default();
        }
        self.acmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_acmt(&mut self) -> Pt {
        self.acmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_acmt(&self) -> &Pt {
        self.acmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt scmt = 3;

    pub fn clear_scmt(&mut self) {
        self.scmt.clear();
    }

    pub fn has_scmt(&self) -> bool {
        self.scmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scmt(&mut self, v: Pt) {
        self.scmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scmt(&mut self) -> &mut Pt {
        if self.scmt.is_none() {
            self.scmt.set_default();
        }
        self.scmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_scmt(&mut self) -> Pt {
        self.scmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_scmt(&self) -> &Pt {
        self.scmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt t1_cmt = 4;

    pub fn clear_t1_cmt(&mut self) {
        self.t1_cmt.clear();
    }

    pub fn has_t1_cmt(&self) -> bool {
        self.t1_cmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t1_cmt(&mut self, v: Pt) {
        self.t1_cmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t1_cmt(&mut self) -> &mut Pt {
        if self.t1_cmt.is_none() {
            self.t1_cmt.set_default();
        }
        self.t1_cmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_t1_cmt(&mut self) -> Pt {
        self.t1_cmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_t1_cmt(&self) -> &Pt {
        self.t1_cmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt t2_cmt = 5;

    pub fn clear_t2_cmt(&mut self) {
        self.t2_cmt.clear();
    }

    pub fn has_t2_cmt(&self) -> bool {
        self.t2_cmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t2_cmt(&mut self, v: Pt) {
        self.t2_cmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t2_cmt(&mut self) -> &mut Pt {
        if self.t2_cmt.is_none() {
            self.t2_cmt.set_default();
        }
        self.t2_cmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_t2_cmt(&mut self) -> Pt {
        self.t2_cmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_t2_cmt(&self) -> &Pt {
        self.t2_cmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Fr tau_x = 6;

    pub fn clear_tau_x(&mut self) {
        self.tau_x.clear();
    }

    pub fn has_tau_x(&self) -> bool {
        self.tau_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tau_x(&mut self, v: Fr) {
        self.tau_x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tau_x(&mut self) -> &mut Fr {
        if self.tau_x.is_none() {
            self.tau_x.set_default();
        }
        self.tau_x.as_mut().unwrap()
    }

    // Take field
    pub fn take_tau_x(&mut self) -> Fr {
        self.tau_x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_tau_x(&self) -> &Fr {
        self.tau_x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr mu = 7;

    pub fn clear_mu(&mut self) {
        self.mu.clear();
    }

    pub fn has_mu(&self) -> bool {
        self.mu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mu(&mut self, v: Fr) {
        self.mu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mu(&mut self) -> &mut Fr {
        if self.mu.is_none() {
            self.mu.set_default();
        }
        self.mu.as_mut().unwrap()
    }

    // Take field
    pub fn take_mu(&mut self) -> Fr {
        self.mu.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_mu(&self) -> &Fr {
        self.mu.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr t_hat = 8;

    pub fn clear_t_hat(&mut self) {
        self.t_hat.clear();
    }

    pub fn has_t_hat(&self) -> bool {
        self.t_hat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_hat(&mut self, v: Fr) {
        self.t_hat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t_hat(&mut self) -> &mut Fr {
        if self.t_hat.is_none() {
            self.t_hat.set_default();
        }
        self.t_hat.as_mut().unwrap()
    }

    // Take field
    pub fn take_t_hat(&mut self) -> Fr {
        self.t_hat.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_t_hat(&self) -> &Fr {
        self.t_hat.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.DotProof dot_proof = 9;

    pub fn clear_dot_proof(&mut self) {
        self.dot_proof.clear();
    }

    pub fn has_dot_proof(&self) -> bool {
        self.dot_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dot_proof(&mut self, v: DotProof) {
        self.dot_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dot_proof(&mut self) -> &mut DotProof {
        if self.dot_proof.is_none() {
            self.dot_proof.set_default();
        }
        self.dot_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_dot_proof(&mut self) -> DotProof {
        self.dot_proof.take().unwrap_or_else(|| DotProof::new())
    }

    pub fn get_dot_proof(&self) -> &DotProof {
        self.dot_proof.as_ref().unwrap_or_else(|| DotProof::default_instance())
    }

    // .protobuf.pb.Fr x = 10;

    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Fr) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Fr {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Fr {
        self.x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_x(&self) -> &Fr {
        self.x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr y = 11;

    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Fr) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Fr {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Fr {
        self.y.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_y(&self) -> &Fr {
        self.y.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr z = 12;

    pub fn clear_z(&mut self) {
        self.z.clear();
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: Fr) {
        self.z = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&mut self) -> &mut Fr {
        if self.z.is_none() {
            self.z.set_default();
        }
        self.z.as_mut().unwrap()
    }

    // Take field
    pub fn take_z(&mut self) -> Fr {
        self.z.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_z(&self) -> &Fr {
        self.z.as_ref().unwrap_or_else(|| Fr::default_instance())
    }
}

impl ::protobuf::Message for BulletProof {
    fn is_initialized(&self) -> bool {
        for v in &self.vcmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t1_cmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t2_cmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tau_x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t_hat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dot_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.z {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vcmt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acmt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scmt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t1_cmt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t2_cmt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tau_x)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mu)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t_hat)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dot_proof)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.z)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vcmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t1_cmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t2_cmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tau_x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t_hat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dot_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vcmt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acmt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scmt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t1_cmt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t2_cmt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tau_x.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mu.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t_hat.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dot_proof.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.z.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulletProof {
        BulletProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "vcmt",
                    |m: &BulletProof| { &m.vcmt },
                    |m: &mut BulletProof| { &mut m.vcmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "acmt",
                    |m: &BulletProof| { &m.acmt },
                    |m: &mut BulletProof| { &mut m.acmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "scmt",
                    |m: &BulletProof| { &m.scmt },
                    |m: &mut BulletProof| { &mut m.scmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "t1_cmt",
                    |m: &BulletProof| { &m.t1_cmt },
                    |m: &mut BulletProof| { &mut m.t1_cmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "t2_cmt",
                    |m: &BulletProof| { &m.t2_cmt },
                    |m: &mut BulletProof| { &mut m.t2_cmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "tau_x",
                    |m: &BulletProof| { &m.tau_x },
                    |m: &mut BulletProof| { &mut m.tau_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "mu",
                    |m: &BulletProof| { &m.mu },
                    |m: &mut BulletProof| { &mut m.mu },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "t_hat",
                    |m: &BulletProof| { &m.t_hat },
                    |m: &mut BulletProof| { &mut m.t_hat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DotProof>>(
                    "dot_proof",
                    |m: &BulletProof| { &m.dot_proof },
                    |m: &mut BulletProof| { &mut m.dot_proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "x",
                    |m: &BulletProof| { &m.x },
                    |m: &mut BulletProof| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "y",
                    |m: &BulletProof| { &m.y },
                    |m: &mut BulletProof| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "z",
                    |m: &BulletProof| { &m.z },
                    |m: &mut BulletProof| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BulletProof>(
                    "BulletProof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BulletProof {
        static mut instance: ::protobuf::lazy::Lazy<BulletProof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BulletProof,
        };
        unsafe {
            instance.get(BulletProof::new)
        }
    }
}

impl ::protobuf::Clear for BulletProof {
    fn clear(&mut self) {
        self.clear_vcmt();
        self.clear_acmt();
        self.clear_scmt();
        self.clear_t1_cmt();
        self.clear_t2_cmt();
        self.clear_tau_x();
        self.clear_mu();
        self.clear_t_hat();
        self.clear_dot_proof();
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulletProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulletProof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Output {
    // message fields
    pub recipient: ::protobuf::SingularPtrField<PublicKey>,
    pub proof: ::protobuf::SingularPtrField<BulletProof>,
    pub vcmt: ::protobuf::SingularPtrField<Pt>,
    pub ttl: u64,
    pub payload: ::protobuf::SingularPtrField<EncryptedPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    // .protobuf.pb.PublicKey recipient = 1;

    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    pub fn has_recipient(&self) -> bool {
        self.recipient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: PublicKey) {
        self.recipient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut PublicKey {
        if self.recipient.is_none() {
            self.recipient.set_default();
        }
        self.recipient.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient(&mut self) -> PublicKey {
        self.recipient.take().unwrap_or_else(|| PublicKey::new())
    }

    pub fn get_recipient(&self) -> &PublicKey {
        self.recipient.as_ref().unwrap_or_else(|| PublicKey::default_instance())
    }

    // .protobuf.pb.BulletProof proof = 2;

    pub fn clear_proof(&mut self) {
        self.proof.clear();
    }

    pub fn has_proof(&self) -> bool {
        self.proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof(&mut self, v: BulletProof) {
        self.proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof(&mut self) -> &mut BulletProof {
        if self.proof.is_none() {
            self.proof.set_default();
        }
        self.proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof(&mut self) -> BulletProof {
        self.proof.take().unwrap_or_else(|| BulletProof::new())
    }

    pub fn get_proof(&self) -> &BulletProof {
        self.proof.as_ref().unwrap_or_else(|| BulletProof::default_instance())
    }

    // .protobuf.pb.Pt vcmt = 4;

    pub fn clear_vcmt(&mut self) {
        self.vcmt.clear();
    }

    pub fn has_vcmt(&self) -> bool {
        self.vcmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vcmt(&mut self, v: Pt) {
        self.vcmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vcmt(&mut self) -> &mut Pt {
        if self.vcmt.is_none() {
            self.vcmt.set_default();
        }
        self.vcmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_vcmt(&mut self) -> Pt {
        self.vcmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_vcmt(&self) -> &Pt {
        self.vcmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // uint64 ttl = 5;

    pub fn clear_ttl(&mut self) {
        self.ttl = 0;
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: u64) {
        self.ttl = v;
    }

    pub fn get_ttl(&self) -> u64 {
        self.ttl
    }

    // .protobuf.pb.EncryptedPayload payload = 3;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: EncryptedPayload) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut EncryptedPayload {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> EncryptedPayload {
        self.payload.take().unwrap_or_else(|| EncryptedPayload::new())
    }

    pub fn get_payload(&self) -> &EncryptedPayload {
        self.payload.as_ref().unwrap_or_else(|| EncryptedPayload::default_instance())
    }
}

impl ::protobuf::Message for Output {
    fn is_initialized(&self) -> bool {
        for v in &self.recipient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vcmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vcmt)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ttl = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recipient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vcmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.ttl != 0 {
            my_size += ::protobuf::rt::value_size(5, self.ttl, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recipient.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.proof.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vcmt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.ttl != 0 {
            os.write_uint64(5, self.ttl)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Output {
        Output::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublicKey>>(
                    "recipient",
                    |m: &Output| { &m.recipient },
                    |m: &mut Output| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulletProof>>(
                    "proof",
                    |m: &Output| { &m.proof },
                    |m: &mut Output| { &mut m.proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "vcmt",
                    |m: &Output| { &m.vcmt },
                    |m: &mut Output| { &mut m.vcmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "ttl",
                    |m: &Output| { &m.ttl },
                    |m: &mut Output| { &mut m.ttl },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedPayload>>(
                    "payload",
                    |m: &Output| { &m.payload },
                    |m: &mut Output| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Output>(
                    "Output",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Output {
        static mut instance: ::protobuf::lazy::Lazy<Output> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Output,
        };
        unsafe {
            instance.get(Output::new)
        }
    }
}

impl ::protobuf::Clear for Output {
    fn clear(&mut self) {
        self.clear_recipient();
        self.clear_proof();
        self.clear_vcmt();
        self.clear_ttl();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub txins: ::protobuf::RepeatedField<Hash>,
    pub txouts: ::protobuf::RepeatedField<Output>,
    pub gamma: ::protobuf::SingularPtrField<Fr>,
    pub fee: i64,
    pub sig: ::protobuf::SingularPtrField<SchnorrSig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // repeated .protobuf.pb.Hash txins = 1;

    pub fn clear_txins(&mut self) {
        self.txins.clear();
    }

    // Param is passed by value, moved
    pub fn set_txins(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.txins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txins(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.txins
    }

    // Take field
    pub fn take_txins(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.txins, ::protobuf::RepeatedField::new())
    }

    pub fn get_txins(&self) -> &[Hash] {
        &self.txins
    }

    // repeated .protobuf.pb.Output txouts = 2;

    pub fn clear_txouts(&mut self) {
        self.txouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_txouts(&mut self, v: ::protobuf::RepeatedField<Output>) {
        self.txouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txouts(&mut self) -> &mut ::protobuf::RepeatedField<Output> {
        &mut self.txouts
    }

    // Take field
    pub fn take_txouts(&mut self) -> ::protobuf::RepeatedField<Output> {
        ::std::mem::replace(&mut self.txouts, ::protobuf::RepeatedField::new())
    }

    pub fn get_txouts(&self) -> &[Output] {
        &self.txouts
    }

    // .protobuf.pb.Fr gamma = 3;

    pub fn clear_gamma(&mut self) {
        self.gamma.clear();
    }

    pub fn has_gamma(&self) -> bool {
        self.gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma(&mut self, v: Fr) {
        self.gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma(&mut self) -> &mut Fr {
        if self.gamma.is_none() {
            self.gamma.set_default();
        }
        self.gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma(&mut self) -> Fr {
        self.gamma.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_gamma(&self) -> &Fr {
        self.gamma.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // int64 fee = 4;

    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    pub fn get_fee(&self) -> i64 {
        self.fee
    }

    // .protobuf.pb.SchnorrSig sig = 5;

    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    pub fn has_sig(&self) -> bool {
        self.sig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: SchnorrSig) {
        self.sig = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut SchnorrSig {
        if self.sig.is_none() {
            self.sig.set_default();
        }
        self.sig.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig(&mut self) -> SchnorrSig {
        self.sig.take().unwrap_or_else(|| SchnorrSig::new())
    }

    pub fn get_sig(&self) -> &SchnorrSig {
        self.sig.as_ref().unwrap_or_else(|| SchnorrSig::default_instance())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.txins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.txouts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txouts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gamma)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.txouts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txins {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.txouts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.gamma.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fee != 0 {
            os.write_int64(4, self.fee)?;
        }
        if let Some(ref v) = self.sig.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "txins",
                    |m: &Transaction| { &m.txins },
                    |m: &mut Transaction| { &mut m.txins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                    "txouts",
                    |m: &Transaction| { &m.txouts },
                    |m: &mut Transaction| { &mut m.txouts },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "gamma",
                    |m: &Transaction| { &m.gamma },
                    |m: &mut Transaction| { &mut m.gamma },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Transaction| { &m.fee },
                    |m: &mut Transaction| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchnorrSig>>(
                    "sig",
                    |m: &Transaction| { &m.sig },
                    |m: &mut Transaction| { &mut m.sig },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.clear_txins();
        self.clear_txouts();
        self.clear_gamma();
        self.clear_fee();
        self.clear_sig();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BaseBlockHeader {
    // message fields
    pub version: u64,
    pub previous: ::protobuf::SingularPtrField<Hash>,
    pub epoch: u64,
    pub timestamp: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BaseBlockHeader {
    pub fn new() -> BaseBlockHeader {
        ::std::default::Default::default()
    }

    // uint64 version = 1;

    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = v;
    }

    pub fn get_version(&self) -> u64 {
        self.version
    }

    // .protobuf.pb.Hash previous = 2;

    pub fn clear_previous(&mut self) {
        self.previous.clear();
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: Hash) {
        self.previous = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous(&mut self) -> &mut Hash {
        if self.previous.is_none() {
            self.previous.set_default();
        }
        self.previous.as_mut().unwrap()
    }

    // Take field
    pub fn take_previous(&mut self) -> Hash {
        self.previous.take().unwrap_or_else(|| Hash::new())
    }

    pub fn get_previous(&self) -> &Hash {
        self.previous.as_ref().unwrap_or_else(|| Hash::default_instance())
    }

    // uint64 epoch = 3;

    pub fn clear_epoch(&mut self) {
        self.epoch = 0;
    }

    // Param is passed by value, moved
    pub fn set_epoch(&mut self, v: u64) {
        self.epoch = v;
    }

    pub fn get_epoch(&self) -> u64 {
        self.epoch
    }

    // uint64 timestamp = 4;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }
}

impl ::protobuf::Message for BaseBlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.previous {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.version = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.previous)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.epoch = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.previous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::value_size(3, self.epoch, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(4, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_uint64(1, self.version)?;
        }
        if let Some(ref v) = self.previous.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.epoch != 0 {
            os.write_uint64(3, self.epoch)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(4, self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BaseBlockHeader {
        BaseBlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "version",
                    |m: &BaseBlockHeader| { &m.version },
                    |m: &mut BaseBlockHeader| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "previous",
                    |m: &BaseBlockHeader| { &m.previous },
                    |m: &mut BaseBlockHeader| { &mut m.previous },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "epoch",
                    |m: &BaseBlockHeader| { &m.epoch },
                    |m: &mut BaseBlockHeader| { &mut m.epoch },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &BaseBlockHeader| { &m.timestamp },
                    |m: &mut BaseBlockHeader| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BaseBlockHeader>(
                    "BaseBlockHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BaseBlockHeader {
        static mut instance: ::protobuf::lazy::Lazy<BaseBlockHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BaseBlockHeader,
        };
        unsafe {
            instance.get(BaseBlockHeader::new)
        }
    }
}

impl ::protobuf::Clear for BaseBlockHeader {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_previous();
        self.clear_epoch();
        self.clear_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BaseBlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseBlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonetaryBlockHeader {
    // message fields
    pub base: ::protobuf::SingularPtrField<BaseBlockHeader>,
    pub gamma: ::protobuf::SingularPtrField<Fr>,
    pub inputs_range_hash: ::protobuf::SingularPtrField<Hash>,
    pub outputs_range_hash: ::protobuf::SingularPtrField<Hash>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MonetaryBlockHeader {
    pub fn new() -> MonetaryBlockHeader {
        ::std::default::Default::default()
    }

    // .protobuf.pb.BaseBlockHeader base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BaseBlockHeader) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BaseBlockHeader {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BaseBlockHeader {
        self.base.take().unwrap_or_else(|| BaseBlockHeader::new())
    }

    pub fn get_base(&self) -> &BaseBlockHeader {
        self.base.as_ref().unwrap_or_else(|| BaseBlockHeader::default_instance())
    }

    // .protobuf.pb.Fr gamma = 2;

    pub fn clear_gamma(&mut self) {
        self.gamma.clear();
    }

    pub fn has_gamma(&self) -> bool {
        self.gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma(&mut self, v: Fr) {
        self.gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma(&mut self) -> &mut Fr {
        if self.gamma.is_none() {
            self.gamma.set_default();
        }
        self.gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma(&mut self) -> Fr {
        self.gamma.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_gamma(&self) -> &Fr {
        self.gamma.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Hash inputs_range_hash = 3;

    pub fn clear_inputs_range_hash(&mut self) {
        self.inputs_range_hash.clear();
    }

    pub fn has_inputs_range_hash(&self) -> bool {
        self.inputs_range_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inputs_range_hash(&mut self, v: Hash) {
        self.inputs_range_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inputs_range_hash(&mut self) -> &mut Hash {
        if self.inputs_range_hash.is_none() {
            self.inputs_range_hash.set_default();
        }
        self.inputs_range_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_inputs_range_hash(&mut self) -> Hash {
        self.inputs_range_hash.take().unwrap_or_else(|| Hash::new())
    }

    pub fn get_inputs_range_hash(&self) -> &Hash {
        self.inputs_range_hash.as_ref().unwrap_or_else(|| Hash::default_instance())
    }

    // .protobuf.pb.Hash outputs_range_hash = 4;

    pub fn clear_outputs_range_hash(&mut self) {
        self.outputs_range_hash.clear();
    }

    pub fn has_outputs_range_hash(&self) -> bool {
        self.outputs_range_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outputs_range_hash(&mut self, v: Hash) {
        self.outputs_range_hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputs_range_hash(&mut self) -> &mut Hash {
        if self.outputs_range_hash.is_none() {
            self.outputs_range_hash.set_default();
        }
        self.outputs_range_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_outputs_range_hash(&mut self) -> Hash {
        self.outputs_range_hash.take().unwrap_or_else(|| Hash::new())
    }

    pub fn get_outputs_range_hash(&self) -> &Hash {
        self.outputs_range_hash.as_ref().unwrap_or_else(|| Hash::default_instance())
    }
}

impl ::protobuf::Message for MonetaryBlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.inputs_range_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs_range_hash {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gamma)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.inputs_range_hash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outputs_range_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.inputs_range_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.outputs_range_hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gamma.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.inputs_range_hash.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.outputs_range_hash.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonetaryBlockHeader {
        MonetaryBlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseBlockHeader>>(
                    "base",
                    |m: &MonetaryBlockHeader| { &m.base },
                    |m: &mut MonetaryBlockHeader| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "gamma",
                    |m: &MonetaryBlockHeader| { &m.gamma },
                    |m: &mut MonetaryBlockHeader| { &mut m.gamma },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "inputs_range_hash",
                    |m: &MonetaryBlockHeader| { &m.inputs_range_hash },
                    |m: &mut MonetaryBlockHeader| { &mut m.inputs_range_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "outputs_range_hash",
                    |m: &MonetaryBlockHeader| { &m.outputs_range_hash },
                    |m: &mut MonetaryBlockHeader| { &mut m.outputs_range_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonetaryBlockHeader>(
                    "MonetaryBlockHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonetaryBlockHeader {
        static mut instance: ::protobuf::lazy::Lazy<MonetaryBlockHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonetaryBlockHeader,
        };
        unsafe {
            instance.get(MonetaryBlockHeader::new)
        }
    }
}

impl ::protobuf::Clear for MonetaryBlockHeader {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_gamma();
        self.clear_inputs_range_hash();
        self.clear_outputs_range_hash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonetaryBlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonetaryBlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MerkleNode {
    // message fields
    pub hash: ::protobuf::SingularPtrField<Hash>,
    pub left: u64,
    pub right: u64,
    pub value: ::protobuf::SingularPtrField<Output>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MerkleNode {
    pub fn new() -> MerkleNode {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Hash hash = 1;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: Hash) {
        self.hash = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut Hash {
        if self.hash.is_none() {
            self.hash.set_default();
        }
        self.hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_hash(&mut self) -> Hash {
        self.hash.take().unwrap_or_else(|| Hash::new())
    }

    pub fn get_hash(&self) -> &Hash {
        self.hash.as_ref().unwrap_or_else(|| Hash::default_instance())
    }

    // uint64 left = 2;

    pub fn clear_left(&mut self) {
        self.left = 0;
    }

    // Param is passed by value, moved
    pub fn set_left(&mut self, v: u64) {
        self.left = v;
    }

    pub fn get_left(&self) -> u64 {
        self.left
    }

    // uint64 right = 3;

    pub fn clear_right(&mut self) {
        self.right = 0;
    }

    // Param is passed by value, moved
    pub fn set_right(&mut self, v: u64) {
        self.right = v;
    }

    pub fn get_right(&self) -> u64 {
        self.right
    }

    // .protobuf.pb.Output value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: Output) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut Output {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> Output {
        self.value.take().unwrap_or_else(|| Output::new())
    }

    pub fn get_value(&self) -> &Output {
        self.value.as_ref().unwrap_or_else(|| Output::default_instance())
    }
}

impl ::protobuf::Message for MerkleNode {
    fn is_initialized(&self) -> bool {
        for v in &self.hash {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.left = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.right = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hash.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.left != 0 {
            my_size += ::protobuf::rt::value_size(2, self.left, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right != 0 {
            my_size += ::protobuf::rt::value_size(3, self.right, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hash.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.left != 0 {
            os.write_uint64(2, self.left)?;
        }
        if self.right != 0 {
            os.write_uint64(3, self.right)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MerkleNode {
        MerkleNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "hash",
                    |m: &MerkleNode| { &m.hash },
                    |m: &mut MerkleNode| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "left",
                    |m: &MerkleNode| { &m.left },
                    |m: &mut MerkleNode| { &mut m.left },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "right",
                    |m: &MerkleNode| { &m.right },
                    |m: &mut MerkleNode| { &mut m.right },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                    "value",
                    |m: &MerkleNode| { &m.value },
                    |m: &mut MerkleNode| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MerkleNode>(
                    "MerkleNode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MerkleNode {
        static mut instance: ::protobuf::lazy::Lazy<MerkleNode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MerkleNode,
        };
        unsafe {
            instance.get(MerkleNode::new)
        }
    }
}

impl ::protobuf::Clear for MerkleNode {
    fn clear(&mut self) {
        self.clear_hash();
        self.clear_left();
        self.clear_right();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MerkleNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerkleNode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonetaryBlockBody {
    // message fields
    pub inputs: ::protobuf::RepeatedField<Hash>,
    pub outputs: ::protobuf::RepeatedField<MerkleNode>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MonetaryBlockBody {
    pub fn new() -> MonetaryBlockBody {
        ::std::default::Default::default()
    }

    // repeated .protobuf.pb.Hash inputs = 1;

    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    pub fn get_inputs(&self) -> &[Hash] {
        &self.inputs
    }

    // repeated .protobuf.pb.MerkleNode outputs = 2;

    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<MerkleNode>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<MerkleNode> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<MerkleNode> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    pub fn get_outputs(&self) -> &[MerkleNode] {
        &self.outputs
    }
}

impl ::protobuf::Message for MonetaryBlockBody {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.inputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonetaryBlockBody {
        MonetaryBlockBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "inputs",
                    |m: &MonetaryBlockBody| { &m.inputs },
                    |m: &mut MonetaryBlockBody| { &mut m.inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MerkleNode>>(
                    "outputs",
                    |m: &MonetaryBlockBody| { &m.outputs },
                    |m: &mut MonetaryBlockBody| { &mut m.outputs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonetaryBlockBody>(
                    "MonetaryBlockBody",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonetaryBlockBody {
        static mut instance: ::protobuf::lazy::Lazy<MonetaryBlockBody> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonetaryBlockBody,
        };
        unsafe {
            instance.get(MonetaryBlockBody::new)
        }
    }
}

impl ::protobuf::Clear for MonetaryBlockBody {
    fn clear(&mut self) {
        self.clear_inputs();
        self.clear_outputs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonetaryBlockBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonetaryBlockBody {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MonetaryBlock {
    // message fields
    pub header: ::protobuf::SingularPtrField<MonetaryBlockHeader>,
    pub body: ::protobuf::SingularPtrField<MonetaryBlockBody>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MonetaryBlock {
    pub fn new() -> MonetaryBlock {
        ::std::default::Default::default()
    }

    // .protobuf.pb.MonetaryBlockHeader header = 1;

    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: MonetaryBlockHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut MonetaryBlockHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> MonetaryBlockHeader {
        self.header.take().unwrap_or_else(|| MonetaryBlockHeader::new())
    }

    pub fn get_header(&self) -> &MonetaryBlockHeader {
        self.header.as_ref().unwrap_or_else(|| MonetaryBlockHeader::default_instance())
    }

    // .protobuf.pb.MonetaryBlockBody body = 2;

    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: MonetaryBlockBody) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut MonetaryBlockBody {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> MonetaryBlockBody {
        self.body.take().unwrap_or_else(|| MonetaryBlockBody::new())
    }

    pub fn get_body(&self) -> &MonetaryBlockBody {
        self.body.as_ref().unwrap_or_else(|| MonetaryBlockBody::default_instance())
    }
}

impl ::protobuf::Message for MonetaryBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MonetaryBlock {
        MonetaryBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonetaryBlockHeader>>(
                    "header",
                    |m: &MonetaryBlock| { &m.header },
                    |m: &mut MonetaryBlock| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MonetaryBlockBody>>(
                    "body",
                    |m: &MonetaryBlock| { &m.body },
                    |m: &mut MonetaryBlock| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MonetaryBlock>(
                    "MonetaryBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MonetaryBlock {
        static mut instance: ::protobuf::lazy::Lazy<MonetaryBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MonetaryBlock,
        };
        unsafe {
            instance.get(MonetaryBlock::new)
        }
    }
}

impl ::protobuf::Clear for MonetaryBlock {
    fn clear(&mut self) {
        self.clear_header();
        self.clear_body();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MonetaryBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MonetaryBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyBlockHeader {
    // message fields
    pub base: ::protobuf::SingularPtrField<BaseBlockHeader>,
    pub leader: ::protobuf::SingularPtrField<SecurePublicKey>,
    pub witnesses: ::protobuf::RepeatedField<SecurePublicKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyBlockHeader {
    pub fn new() -> KeyBlockHeader {
        ::std::default::Default::default()
    }

    // .protobuf.pb.BaseBlockHeader base = 1;

    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: BaseBlockHeader) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut BaseBlockHeader {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> BaseBlockHeader {
        self.base.take().unwrap_or_else(|| BaseBlockHeader::new())
    }

    pub fn get_base(&self) -> &BaseBlockHeader {
        self.base.as_ref().unwrap_or_else(|| BaseBlockHeader::default_instance())
    }

    // .protobuf.pb.SecurePublicKey leader = 2;

    pub fn clear_leader(&mut self) {
        self.leader.clear();
    }

    pub fn has_leader(&self) -> bool {
        self.leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader(&mut self, v: SecurePublicKey) {
        self.leader = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leader(&mut self) -> &mut SecurePublicKey {
        if self.leader.is_none() {
            self.leader.set_default();
        }
        self.leader.as_mut().unwrap()
    }

    // Take field
    pub fn take_leader(&mut self) -> SecurePublicKey {
        self.leader.take().unwrap_or_else(|| SecurePublicKey::new())
    }

    pub fn get_leader(&self) -> &SecurePublicKey {
        self.leader.as_ref().unwrap_or_else(|| SecurePublicKey::default_instance())
    }

    // repeated .protobuf.pb.SecurePublicKey witnesses = 3;

    pub fn clear_witnesses(&mut self) {
        self.witnesses.clear();
    }

    // Param is passed by value, moved
    pub fn set_witnesses(&mut self, v: ::protobuf::RepeatedField<SecurePublicKey>) {
        self.witnesses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_witnesses(&mut self) -> &mut ::protobuf::RepeatedField<SecurePublicKey> {
        &mut self.witnesses
    }

    // Take field
    pub fn take_witnesses(&mut self) -> ::protobuf::RepeatedField<SecurePublicKey> {
        ::std::mem::replace(&mut self.witnesses, ::protobuf::RepeatedField::new())
    }

    pub fn get_witnesses(&self) -> &[SecurePublicKey] {
        &self.witnesses
    }
}

impl ::protobuf::Message for KeyBlockHeader {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.leader {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.witnesses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.leader)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.witnesses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.leader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.witnesses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.leader.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.witnesses {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyBlockHeader {
        KeyBlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BaseBlockHeader>>(
                    "base",
                    |m: &KeyBlockHeader| { &m.base },
                    |m: &mut KeyBlockHeader| { &mut m.base },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurePublicKey>>(
                    "leader",
                    |m: &KeyBlockHeader| { &m.leader },
                    |m: &mut KeyBlockHeader| { &mut m.leader },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurePublicKey>>(
                    "witnesses",
                    |m: &KeyBlockHeader| { &m.witnesses },
                    |m: &mut KeyBlockHeader| { &mut m.witnesses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyBlockHeader>(
                    "KeyBlockHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyBlockHeader {
        static mut instance: ::protobuf::lazy::Lazy<KeyBlockHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyBlockHeader,
        };
        unsafe {
            instance.get(KeyBlockHeader::new)
        }
    }
}

impl ::protobuf::Clear for KeyBlockHeader {
    fn clear(&mut self) {
        self.clear_base();
        self.clear_leader();
        self.clear_witnesses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyBlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyBlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyBlock {
    // message fields
    pub header: ::protobuf::SingularPtrField<KeyBlockHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyBlock {
    pub fn new() -> KeyBlock {
        ::std::default::Default::default()
    }

    // .protobuf.pb.KeyBlockHeader header = 1;

    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: KeyBlockHeader) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut KeyBlockHeader {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> KeyBlockHeader {
        self.header.take().unwrap_or_else(|| KeyBlockHeader::new())
    }

    pub fn get_header(&self) -> &KeyBlockHeader {
        self.header.as_ref().unwrap_or_else(|| KeyBlockHeader::default_instance())
    }
}

impl ::protobuf::Message for KeyBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyBlock {
        KeyBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyBlockHeader>>(
                    "header",
                    |m: &KeyBlock| { &m.header },
                    |m: &mut KeyBlock| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyBlock>(
                    "KeyBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyBlock {
        static mut instance: ::protobuf::lazy::Lazy<KeyBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyBlock,
        };
        unsafe {
            instance.get(KeyBlock::new)
        }
    }
}

impl ::protobuf::Clear for KeyBlock {
    fn clear(&mut self) {
        self.clear_header();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message oneof groups
    pub block: ::std::option::Option<Block_oneof_block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Block_oneof_block {
    key_block(KeyBlock),
    monetary_block(MonetaryBlock),
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // .protobuf.pb.KeyBlock key_block = 1;

    pub fn clear_key_block(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_key_block(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::key_block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_block(&mut self, v: KeyBlock) {
        self.block = ::std::option::Option::Some(Block_oneof_block::key_block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_block(&mut self) -> &mut KeyBlock {
        if let ::std::option::Option::Some(Block_oneof_block::key_block(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Block_oneof_block::key_block(KeyBlock::new()));
        }
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::key_block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_block(&mut self) -> KeyBlock {
        if self.has_key_block() {
            match self.block.take() {
                ::std::option::Option::Some(Block_oneof_block::key_block(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyBlock::new()
        }
    }

    pub fn get_key_block(&self) -> &KeyBlock {
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::key_block(ref v)) => v,
            _ => KeyBlock::default_instance(),
        }
    }

    // .protobuf.pb.MonetaryBlock monetary_block = 2;

    pub fn clear_monetary_block(&mut self) {
        self.block = ::std::option::Option::None;
    }

    pub fn has_monetary_block(&self) -> bool {
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::monetary_block(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_monetary_block(&mut self, v: MonetaryBlock) {
        self.block = ::std::option::Option::Some(Block_oneof_block::monetary_block(v))
    }

    // Mutable pointer to the field.
    pub fn mut_monetary_block(&mut self) -> &mut MonetaryBlock {
        if let ::std::option::Option::Some(Block_oneof_block::monetary_block(_)) = self.block {
        } else {
            self.block = ::std::option::Option::Some(Block_oneof_block::monetary_block(MonetaryBlock::new()));
        }
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::monetary_block(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_monetary_block(&mut self) -> MonetaryBlock {
        if self.has_monetary_block() {
            match self.block.take() {
                ::std::option::Option::Some(Block_oneof_block::monetary_block(v)) => v,
                _ => panic!(),
            }
        } else {
            MonetaryBlock::new()
        }
    }

    pub fn get_monetary_block(&self) -> &MonetaryBlock {
        match self.block {
            ::std::option::Option::Some(Block_oneof_block::monetary_block(ref v)) => v,
            _ => MonetaryBlock::default_instance(),
        }
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        if let Some(Block_oneof_block::key_block(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Block_oneof_block::monetary_block(ref v)) = self.block {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Block_oneof_block::key_block(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.block = ::std::option::Option::Some(Block_oneof_block::monetary_block(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &Block_oneof_block::key_block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Block_oneof_block::monetary_block(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.block {
            match v {
                &Block_oneof_block::key_block(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Block_oneof_block::monetary_block(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyBlock>(
                    "key_block",
                    Block::has_key_block,
                    Block::get_key_block,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MonetaryBlock>(
                    "monetary_block",
                    Block::has_monetary_block,
                    Block::get_monetary_block,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.clear_key_block();
        self.clear_monetary_block();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nnode.proto\x12\x0bprotobuf.pb\"\x16\n\x02Pt\x12\x10\n\x04data\x18\
    \x01\x20\x01(\x0cB\x02\x18\0\"\x16\n\x02Fr\x12\x10\n\x04data\x18\x01\x20\
    \x01(\x0cB\x02\x18\0\"\x16\n\x02G2\x12\x10\n\x04data\x18\x01\x20\x01(\
    \x0cB\x02\x18\0\"\x18\n\x04Hash\x12\x10\n\x04data\x18\x01\x20\x01(\x0cB\
    \x02\x18\0\"/\n\tPublicKey\x12\"\n\x05point\x18\x01\x20\x01(\x0b2\x0f.pr\
    otobuf.pb.PtB\x02\x18\0\"L\n\nSchnorrSig\x12\x1e\n\x01u\x18\x01\x20\x01(\
    \x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01K\x18\x02\x20\x01(\x0b2\
    \x0f.protobuf.pb.PtB\x02\x18\0\"5\n\x0fSecurePublicKey\x12\"\n\x05point\
    \x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.G2B\x02\x18\0\"h\n\x10EncryptedPa\
    yload\x12!\n\x04apkg\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\
    \x12\x1f\n\x02ag\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\
    \x10\n\x04ctxt\x18\x03\x20\x01(\x0cB\x02\x18\0\"d\n\x02LR\x12\x1e\n\x01x\
    \x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01l\x18\
    \x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x1e\n\x01r\x18\x03\
    \x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\"\xb0\x01\n\x08DotProof\x12\
    \x1e\n\x01u\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12!\n\
    \x04pcmt\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x1e\n\
    \x01a\x18\x03\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01b\
    \x18\x04\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12!\n\x04xlrs\x18\
    \x05\x20\x03(\x0b2\x0f.protobuf.pb.LRB\x02\x18\0\"\xb7\x03\n\x0bBulletPr\
    oof\x12!\n\x04vcmt\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\
    \x12!\n\x04acmt\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12!\
    \n\x04scmt\x18\x03\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12#\n\
    \x06t1_cmt\x18\x04\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12#\n\
    \x06t2_cmt\x18\x05\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\"\n\
    \x05tau_x\x18\x06\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1f\n\
    \x02mu\x18\x07\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\"\n\x05t_\
    hat\x18\x08\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12,\n\tdot_proo\
    f\x18\t\x20\x01(\x0b2\x15.protobuf.pb.DotProofB\x02\x18\0\x12\x1e\n\x01x\
    \x18\n\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01y\x18\
    \x0b\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01z\x18\x0c\
    \x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\"\xcc\x01\n\x06Output\x12-\
    \n\trecipient\x18\x01\x20\x01(\x0b2\x16.protobuf.pb.PublicKeyB\x02\x18\0\
    \x12+\n\x05proof\x18\x02\x20\x01(\x0b2\x18.protobuf.pb.BulletProofB\x02\
    \x18\0\x12!\n\x04vcmt\x18\x04\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\
    \0\x12\x0f\n\x03ttl\x18\x05\x20\x01(\x04B\x02\x18\0\x122\n\x07payload\
    \x18\x03\x20\x01(\x0b2\x1d.protobuf.pb.EncryptedPayloadB\x02\x18\0\"\xbb\
    \x01\n\x0bTransaction\x12$\n\x05txins\x18\x01\x20\x03(\x0b2\x11.protobuf\
    .pb.HashB\x02\x18\0\x12'\n\x06txouts\x18\x02\x20\x03(\x0b2\x13.protobuf.\
    pb.OutputB\x02\x18\0\x12\"\n\x05gamma\x18\x03\x20\x01(\x0b2\x0f.protobuf\
    .pb.FrB\x02\x18\0\x12\x0f\n\x03fee\x18\x04\x20\x01(\x03B\x02\x18\0\x12(\
    \n\x03sig\x18\x05\x20\x01(\x0b2\x17.protobuf.pb.SchnorrSigB\x02\x18\0\"y\
    \n\x0fBaseBlockHeader\x12\x13\n\x07version\x18\x01\x20\x01(\x04B\x02\x18\
    \0\x12'\n\x08previous\x18\x02\x20\x01(\x0b2\x11.protobuf.pb.HashB\x02\
    \x18\0\x12\x11\n\x05epoch\x18\x03\x20\x01(\x04B\x02\x18\0\x12\x15\n\ttim\
    estamp\x18\x04\x20\x01(\x04B\x02\x18\0\"\xce\x01\n\x13MonetaryBlockHeade\
    r\x12.\n\x04base\x18\x01\x20\x01(\x0b2\x1c.protobuf.pb.BaseBlockHeaderB\
    \x02\x18\0\x12\"\n\x05gamma\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.FrB\
    \x02\x18\0\x120\n\x11inputs_range_hash\x18\x03\x20\x01(\x0b2\x11.protobu\
    f.pb.HashB\x02\x18\0\x121\n\x12outputs_range_hash\x18\x04\x20\x01(\x0b2\
    \x11.protobuf.pb.HashB\x02\x18\0\"~\n\nMerkleNode\x12#\n\x04hash\x18\x01\
    \x20\x01(\x0b2\x11.protobuf.pb.HashB\x02\x18\0\x12\x10\n\x04left\x18\x02\
    \x20\x01(\x04B\x02\x18\0\x12\x11\n\x05right\x18\x03\x20\x01(\x04B\x02\
    \x18\0\x12&\n\x05value\x18\x04\x20\x01(\x0b2\x13.protobuf.pb.OutputB\x02\
    \x18\0\"h\n\x11MonetaryBlockBody\x12%\n\x06inputs\x18\x01\x20\x03(\x0b2\
    \x11.protobuf.pb.HashB\x02\x18\0\x12,\n\x07outputs\x18\x02\x20\x03(\x0b2\
    \x17.protobuf.pb.MerkleNodeB\x02\x18\0\"w\n\rMonetaryBlock\x124\n\x06hea\
    der\x18\x01\x20\x01(\x0b2\x20.protobuf.pb.MonetaryBlockHeaderB\x02\x18\0\
    \x120\n\x04body\x18\x02\x20\x01(\x0b2\x1e.protobuf.pb.MonetaryBlockBodyB\
    \x02\x18\0\"\xa7\x01\n\x0eKeyBlockHeader\x12.\n\x04base\x18\x01\x20\x01(\
    \x0b2\x1c.protobuf.pb.BaseBlockHeaderB\x02\x18\0\x120\n\x06leader\x18\
    \x02\x20\x01(\x0b2\x1c.protobuf.pb.SecurePublicKeyB\x02\x18\0\x123\n\twi\
    tnesses\x18\x03\x20\x03(\x0b2\x1c.protobuf.pb.SecurePublicKeyB\x02\x18\0\
    \";\n\x08KeyBlock\x12/\n\x06header\x18\x01\x20\x01(\x0b2\x1b.protobuf.pb\
    .KeyBlockHeaderB\x02\x18\0\"z\n\x05Block\x12.\n\tkey_block\x18\x01\x20\
    \x01(\x0b2\x15.protobuf.pb.KeyBlockH\0B\x02\x18\0\x128\n\x0emonetary_blo\
    ck\x18\x02\x20\x01(\x0b2\x1a.protobuf.pb.MonetaryBlockH\0B\x02\x18\0B\
    \x07\n\x05blockB\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
