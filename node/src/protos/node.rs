// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Pt {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Pt {
    pub fn new() -> Pt {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Pt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pt {
        Pt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Pt| { &m.data },
                    |m: &mut Pt| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Pt>(
                    "Pt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Pt {
        static mut instance: ::protobuf::lazy::Lazy<Pt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Pt,
        };
        unsafe {
            instance.get(Pt::new)
        }
    }
}

impl ::protobuf::Clear for Pt {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Fr {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Fr {
    pub fn new() -> Fr {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Fr {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Fr {
        Fr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Fr| { &m.data },
                    |m: &mut Fr| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Fr>(
                    "Fr",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Fr {
        static mut instance: ::protobuf::lazy::Lazy<Fr> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Fr,
        };
        unsafe {
            instance.get(Fr::new)
        }
    }
}

impl ::protobuf::Clear for Fr {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Fr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Fr {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Hash {
    // message fields
    pub data: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Hash {
    pub fn new() -> Hash {
        ::std::default::Default::default()
    }

    // bytes data = 1;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }
}

impl ::protobuf::Message for Hash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Hash {
        Hash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &Hash| { &m.data },
                    |m: &mut Hash| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Hash>(
                    "Hash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Hash {
        static mut instance: ::protobuf::lazy::Lazy<Hash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Hash,
        };
        unsafe {
            instance.get(Hash::new)
        }
    }
}

impl ::protobuf::Clear for Hash {
    fn clear(&mut self) {
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Hash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Hash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PublicKey {
    // message fields
    pub point: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl PublicKey {
    pub fn new() -> PublicKey {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt point = 1;

    pub fn clear_point(&mut self) {
        self.point.clear();
    }

    pub fn has_point(&self) -> bool {
        self.point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_point(&mut self, v: Pt) {
        self.point = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_point(&mut self) -> &mut Pt {
        if self.point.is_none() {
            self.point.set_default();
        }
        self.point.as_mut().unwrap()
    }

    // Take field
    pub fn take_point(&mut self) -> Pt {
        self.point.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_point(&self) -> &Pt {
        self.point.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for PublicKey {
    fn is_initialized(&self) -> bool {
        for v in &self.point {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.point)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.point.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PublicKey {
        PublicKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "point",
                    |m: &PublicKey| { &m.point },
                    |m: &mut PublicKey| { &mut m.point },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PublicKey>(
                    "PublicKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PublicKey {
        static mut instance: ::protobuf::lazy::Lazy<PublicKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PublicKey,
        };
        unsafe {
            instance.get(PublicKey::new)
        }
    }
}

impl ::protobuf::Clear for PublicKey {
    fn clear(&mut self) {
        self.clear_point();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PublicKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchnorrSig {
    // message fields
    pub u: ::protobuf::SingularPtrField<Fr>,
    pub K: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SchnorrSig {
    pub fn new() -> SchnorrSig {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Fr u = 1;

    pub fn clear_u(&mut self) {
        self.u.clear();
    }

    pub fn has_u(&self) -> bool {
        self.u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u(&mut self, v: Fr) {
        self.u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u(&mut self) -> &mut Fr {
        if self.u.is_none() {
            self.u.set_default();
        }
        self.u.as_mut().unwrap()
    }

    // Take field
    pub fn take_u(&mut self) -> Fr {
        self.u.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_u(&self) -> &Fr {
        self.u.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Pt K = 2;

    pub fn clear_K(&mut self) {
        self.K.clear();
    }

    pub fn has_K(&self) -> bool {
        self.K.is_some()
    }

    // Param is passed by value, moved
    pub fn set_K(&mut self, v: Pt) {
        self.K = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_K(&mut self) -> &mut Pt {
        if self.K.is_none() {
            self.K.set_default();
        }
        self.K.as_mut().unwrap()
    }

    // Take field
    pub fn take_K(&mut self) -> Pt {
        self.K.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_K(&self) -> &Pt {
        self.K.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for SchnorrSig {
    fn is_initialized(&self) -> bool {
        for v in &self.u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.K {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.u)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.K)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.K.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.u.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.K.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchnorrSig {
        SchnorrSig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "u",
                    |m: &SchnorrSig| { &m.u },
                    |m: &mut SchnorrSig| { &mut m.u },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "K",
                    |m: &SchnorrSig| { &m.K },
                    |m: &mut SchnorrSig| { &mut m.K },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SchnorrSig>(
                    "SchnorrSig",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SchnorrSig {
        static mut instance: ::protobuf::lazy::Lazy<SchnorrSig> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SchnorrSig,
        };
        unsafe {
            instance.get(SchnorrSig::new)
        }
    }
}

impl ::protobuf::Clear for SchnorrSig {
    fn clear(&mut self) {
        self.clear_u();
        self.clear_K();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchnorrSig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchnorrSig {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncryptedPayload {
    // message fields
    pub apkg: ::protobuf::SingularPtrField<Pt>,
    pub ag: ::protobuf::SingularPtrField<Pt>,
    pub ctxt: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EncryptedPayload {
    pub fn new() -> EncryptedPayload {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt apkg = 1;

    pub fn clear_apkg(&mut self) {
        self.apkg.clear();
    }

    pub fn has_apkg(&self) -> bool {
        self.apkg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apkg(&mut self, v: Pt) {
        self.apkg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apkg(&mut self) -> &mut Pt {
        if self.apkg.is_none() {
            self.apkg.set_default();
        }
        self.apkg.as_mut().unwrap()
    }

    // Take field
    pub fn take_apkg(&mut self) -> Pt {
        self.apkg.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_apkg(&self) -> &Pt {
        self.apkg.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt ag = 2;

    pub fn clear_ag(&mut self) {
        self.ag.clear();
    }

    pub fn has_ag(&self) -> bool {
        self.ag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ag(&mut self, v: Pt) {
        self.ag = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ag(&mut self) -> &mut Pt {
        if self.ag.is_none() {
            self.ag.set_default();
        }
        self.ag.as_mut().unwrap()
    }

    // Take field
    pub fn take_ag(&mut self) -> Pt {
        self.ag.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_ag(&self) -> &Pt {
        self.ag.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // bytes ctxt = 3;

    pub fn clear_ctxt(&mut self) {
        self.ctxt.clear();
    }

    // Param is passed by value, moved
    pub fn set_ctxt(&mut self, v: ::std::vec::Vec<u8>) {
        self.ctxt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ctxt(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ctxt
    }

    // Take field
    pub fn take_ctxt(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ctxt, ::std::vec::Vec::new())
    }

    pub fn get_ctxt(&self) -> &[u8] {
        &self.ctxt
    }
}

impl ::protobuf::Message for EncryptedPayload {
    fn is_initialized(&self) -> bool {
        for v in &self.apkg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ag {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.apkg)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ag)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ctxt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apkg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ag.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.ctxt.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ctxt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apkg.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ag.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.ctxt.is_empty() {
            os.write_bytes(3, &self.ctxt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncryptedPayload {
        EncryptedPayload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "apkg",
                    |m: &EncryptedPayload| { &m.apkg },
                    |m: &mut EncryptedPayload| { &mut m.apkg },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "ag",
                    |m: &EncryptedPayload| { &m.ag },
                    |m: &mut EncryptedPayload| { &mut m.ag },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ctxt",
                    |m: &EncryptedPayload| { &m.ctxt },
                    |m: &mut EncryptedPayload| { &mut m.ctxt },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EncryptedPayload>(
                    "EncryptedPayload",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EncryptedPayload {
        static mut instance: ::protobuf::lazy::Lazy<EncryptedPayload> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EncryptedPayload,
        };
        unsafe {
            instance.get(EncryptedPayload::new)
        }
    }
}

impl ::protobuf::Clear for EncryptedPayload {
    fn clear(&mut self) {
        self.clear_apkg();
        self.clear_ag();
        self.clear_ctxt();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncryptedPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncryptedPayload {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LR {
    // message fields
    pub x: ::protobuf::SingularPtrField<Fr>,
    pub l: ::protobuf::SingularPtrField<Pt>,
    pub r: ::protobuf::SingularPtrField<Pt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl LR {
    pub fn new() -> LR {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Fr x = 1;

    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Fr) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Fr {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Fr {
        self.x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_x(&self) -> &Fr {
        self.x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Pt l = 2;

    pub fn clear_l(&mut self) {
        self.l.clear();
    }

    pub fn has_l(&self) -> bool {
        self.l.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l(&mut self, v: Pt) {
        self.l = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_l(&mut self) -> &mut Pt {
        if self.l.is_none() {
            self.l.set_default();
        }
        self.l.as_mut().unwrap()
    }

    // Take field
    pub fn take_l(&mut self) -> Pt {
        self.l.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_l(&self) -> &Pt {
        self.l.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt r = 3;

    pub fn clear_r(&mut self) {
        self.r.clear();
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: Pt) {
        self.r = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_r(&mut self) -> &mut Pt {
        if self.r.is_none() {
            self.r.set_default();
        }
        self.r.as_mut().unwrap()
    }

    // Take field
    pub fn take_r(&mut self) -> Pt {
        self.r.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_r(&self) -> &Pt {
        self.r.as_ref().unwrap_or_else(|| Pt::default_instance())
    }
}

impl ::protobuf::Message for LR {
    fn is_initialized(&self) -> bool {
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.l {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.r {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.l)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.r)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.l.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.r.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.l.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.r.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LR {
        LR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "x",
                    |m: &LR| { &m.x },
                    |m: &mut LR| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "l",
                    |m: &LR| { &m.l },
                    |m: &mut LR| { &mut m.l },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "r",
                    |m: &LR| { &m.r },
                    |m: &mut LR| { &mut m.r },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LR>(
                    "LR",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LR {
        static mut instance: ::protobuf::lazy::Lazy<LR> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LR,
        };
        unsafe {
            instance.get(LR::new)
        }
    }
}

impl ::protobuf::Clear for LR {
    fn clear(&mut self) {
        self.clear_x();
        self.clear_l();
        self.clear_r();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LR {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DotProof {
    // message fields
    pub u: ::protobuf::SingularPtrField<Pt>,
    pub pcmt: ::protobuf::SingularPtrField<Pt>,
    pub a: ::protobuf::SingularPtrField<Fr>,
    pub b: ::protobuf::SingularPtrField<Fr>,
    pub xlrs: ::protobuf::RepeatedField<LR>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DotProof {
    pub fn new() -> DotProof {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt u = 1;

    pub fn clear_u(&mut self) {
        self.u.clear();
    }

    pub fn has_u(&self) -> bool {
        self.u.is_some()
    }

    // Param is passed by value, moved
    pub fn set_u(&mut self, v: Pt) {
        self.u = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u(&mut self) -> &mut Pt {
        if self.u.is_none() {
            self.u.set_default();
        }
        self.u.as_mut().unwrap()
    }

    // Take field
    pub fn take_u(&mut self) -> Pt {
        self.u.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_u(&self) -> &Pt {
        self.u.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt pcmt = 2;

    pub fn clear_pcmt(&mut self) {
        self.pcmt.clear();
    }

    pub fn has_pcmt(&self) -> bool {
        self.pcmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pcmt(&mut self, v: Pt) {
        self.pcmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pcmt(&mut self) -> &mut Pt {
        if self.pcmt.is_none() {
            self.pcmt.set_default();
        }
        self.pcmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_pcmt(&mut self) -> Pt {
        self.pcmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_pcmt(&self) -> &Pt {
        self.pcmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Fr a = 3;

    pub fn clear_a(&mut self) {
        self.a.clear();
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: Fr) {
        self.a = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_a(&mut self) -> &mut Fr {
        if self.a.is_none() {
            self.a.set_default();
        }
        self.a.as_mut().unwrap()
    }

    // Take field
    pub fn take_a(&mut self) -> Fr {
        self.a.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_a(&self) -> &Fr {
        self.a.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr b = 4;

    pub fn clear_b(&mut self) {
        self.b.clear();
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: Fr) {
        self.b = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_b(&mut self) -> &mut Fr {
        if self.b.is_none() {
            self.b.set_default();
        }
        self.b.as_mut().unwrap()
    }

    // Take field
    pub fn take_b(&mut self) -> Fr {
        self.b.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_b(&self) -> &Fr {
        self.b.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // repeated .protobuf.pb.LR xlrs = 5;

    pub fn clear_xlrs(&mut self) {
        self.xlrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_xlrs(&mut self, v: ::protobuf::RepeatedField<LR>) {
        self.xlrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xlrs(&mut self) -> &mut ::protobuf::RepeatedField<LR> {
        &mut self.xlrs
    }

    // Take field
    pub fn take_xlrs(&mut self) -> ::protobuf::RepeatedField<LR> {
        ::std::mem::replace(&mut self.xlrs, ::protobuf::RepeatedField::new())
    }

    pub fn get_xlrs(&self) -> &[LR] {
        &self.xlrs
    }
}

impl ::protobuf::Message for DotProof {
    fn is_initialized(&self) -> bool {
        for v in &self.u {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pcmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.a {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.b {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xlrs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.u)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pcmt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.a)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.b)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.xlrs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.u.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pcmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.xlrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.u.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pcmt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.a.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.b.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.xlrs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DotProof {
        DotProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "u",
                    |m: &DotProof| { &m.u },
                    |m: &mut DotProof| { &mut m.u },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "pcmt",
                    |m: &DotProof| { &m.pcmt },
                    |m: &mut DotProof| { &mut m.pcmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "a",
                    |m: &DotProof| { &m.a },
                    |m: &mut DotProof| { &mut m.a },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "b",
                    |m: &DotProof| { &m.b },
                    |m: &mut DotProof| { &mut m.b },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LR>>(
                    "xlrs",
                    |m: &DotProof| { &m.xlrs },
                    |m: &mut DotProof| { &mut m.xlrs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DotProof>(
                    "DotProof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DotProof {
        static mut instance: ::protobuf::lazy::Lazy<DotProof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DotProof,
        };
        unsafe {
            instance.get(DotProof::new)
        }
    }
}

impl ::protobuf::Clear for DotProof {
    fn clear(&mut self) {
        self.clear_u();
        self.clear_pcmt();
        self.clear_a();
        self.clear_b();
        self.clear_xlrs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DotProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DotProof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BulletProof {
    // message fields
    pub vcmt: ::protobuf::SingularPtrField<Pt>,
    pub acmt: ::protobuf::SingularPtrField<Pt>,
    pub scmt: ::protobuf::SingularPtrField<Pt>,
    pub t1_cmt: ::protobuf::SingularPtrField<Pt>,
    pub t2_cmt: ::protobuf::SingularPtrField<Pt>,
    pub tau_x: ::protobuf::SingularPtrField<Fr>,
    pub mu: ::protobuf::SingularPtrField<Fr>,
    pub t_hat: ::protobuf::SingularPtrField<Fr>,
    pub dot_proof: ::protobuf::SingularPtrField<DotProof>,
    pub x: ::protobuf::SingularPtrField<Fr>,
    pub y: ::protobuf::SingularPtrField<Fr>,
    pub z: ::protobuf::SingularPtrField<Fr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl BulletProof {
    pub fn new() -> BulletProof {
        ::std::default::Default::default()
    }

    // .protobuf.pb.Pt vcmt = 1;

    pub fn clear_vcmt(&mut self) {
        self.vcmt.clear();
    }

    pub fn has_vcmt(&self) -> bool {
        self.vcmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vcmt(&mut self, v: Pt) {
        self.vcmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vcmt(&mut self) -> &mut Pt {
        if self.vcmt.is_none() {
            self.vcmt.set_default();
        }
        self.vcmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_vcmt(&mut self) -> Pt {
        self.vcmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_vcmt(&self) -> &Pt {
        self.vcmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt acmt = 2;

    pub fn clear_acmt(&mut self) {
        self.acmt.clear();
    }

    pub fn has_acmt(&self) -> bool {
        self.acmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acmt(&mut self, v: Pt) {
        self.acmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acmt(&mut self) -> &mut Pt {
        if self.acmt.is_none() {
            self.acmt.set_default();
        }
        self.acmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_acmt(&mut self) -> Pt {
        self.acmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_acmt(&self) -> &Pt {
        self.acmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt scmt = 3;

    pub fn clear_scmt(&mut self) {
        self.scmt.clear();
    }

    pub fn has_scmt(&self) -> bool {
        self.scmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scmt(&mut self, v: Pt) {
        self.scmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scmt(&mut self) -> &mut Pt {
        if self.scmt.is_none() {
            self.scmt.set_default();
        }
        self.scmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_scmt(&mut self) -> Pt {
        self.scmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_scmt(&self) -> &Pt {
        self.scmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt t1_cmt = 4;

    pub fn clear_t1_cmt(&mut self) {
        self.t1_cmt.clear();
    }

    pub fn has_t1_cmt(&self) -> bool {
        self.t1_cmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t1_cmt(&mut self, v: Pt) {
        self.t1_cmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t1_cmt(&mut self) -> &mut Pt {
        if self.t1_cmt.is_none() {
            self.t1_cmt.set_default();
        }
        self.t1_cmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_t1_cmt(&mut self) -> Pt {
        self.t1_cmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_t1_cmt(&self) -> &Pt {
        self.t1_cmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Pt t2_cmt = 5;

    pub fn clear_t2_cmt(&mut self) {
        self.t2_cmt.clear();
    }

    pub fn has_t2_cmt(&self) -> bool {
        self.t2_cmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t2_cmt(&mut self, v: Pt) {
        self.t2_cmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t2_cmt(&mut self) -> &mut Pt {
        if self.t2_cmt.is_none() {
            self.t2_cmt.set_default();
        }
        self.t2_cmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_t2_cmt(&mut self) -> Pt {
        self.t2_cmt.take().unwrap_or_else(|| Pt::new())
    }

    pub fn get_t2_cmt(&self) -> &Pt {
        self.t2_cmt.as_ref().unwrap_or_else(|| Pt::default_instance())
    }

    // .protobuf.pb.Fr tau_x = 6;

    pub fn clear_tau_x(&mut self) {
        self.tau_x.clear();
    }

    pub fn has_tau_x(&self) -> bool {
        self.tau_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tau_x(&mut self, v: Fr) {
        self.tau_x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tau_x(&mut self) -> &mut Fr {
        if self.tau_x.is_none() {
            self.tau_x.set_default();
        }
        self.tau_x.as_mut().unwrap()
    }

    // Take field
    pub fn take_tau_x(&mut self) -> Fr {
        self.tau_x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_tau_x(&self) -> &Fr {
        self.tau_x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr mu = 7;

    pub fn clear_mu(&mut self) {
        self.mu.clear();
    }

    pub fn has_mu(&self) -> bool {
        self.mu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mu(&mut self, v: Fr) {
        self.mu = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mu(&mut self) -> &mut Fr {
        if self.mu.is_none() {
            self.mu.set_default();
        }
        self.mu.as_mut().unwrap()
    }

    // Take field
    pub fn take_mu(&mut self) -> Fr {
        self.mu.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_mu(&self) -> &Fr {
        self.mu.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr t_hat = 8;

    pub fn clear_t_hat(&mut self) {
        self.t_hat.clear();
    }

    pub fn has_t_hat(&self) -> bool {
        self.t_hat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t_hat(&mut self, v: Fr) {
        self.t_hat = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t_hat(&mut self) -> &mut Fr {
        if self.t_hat.is_none() {
            self.t_hat.set_default();
        }
        self.t_hat.as_mut().unwrap()
    }

    // Take field
    pub fn take_t_hat(&mut self) -> Fr {
        self.t_hat.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_t_hat(&self) -> &Fr {
        self.t_hat.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.DotProof dot_proof = 9;

    pub fn clear_dot_proof(&mut self) {
        self.dot_proof.clear();
    }

    pub fn has_dot_proof(&self) -> bool {
        self.dot_proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dot_proof(&mut self, v: DotProof) {
        self.dot_proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dot_proof(&mut self) -> &mut DotProof {
        if self.dot_proof.is_none() {
            self.dot_proof.set_default();
        }
        self.dot_proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_dot_proof(&mut self) -> DotProof {
        self.dot_proof.take().unwrap_or_else(|| DotProof::new())
    }

    pub fn get_dot_proof(&self) -> &DotProof {
        self.dot_proof.as_ref().unwrap_or_else(|| DotProof::default_instance())
    }

    // .protobuf.pb.Fr x = 10;

    pub fn clear_x(&mut self) {
        self.x.clear();
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: Fr) {
        self.x = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_x(&mut self) -> &mut Fr {
        if self.x.is_none() {
            self.x.set_default();
        }
        self.x.as_mut().unwrap()
    }

    // Take field
    pub fn take_x(&mut self) -> Fr {
        self.x.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_x(&self) -> &Fr {
        self.x.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr y = 11;

    pub fn clear_y(&mut self) {
        self.y.clear();
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: Fr) {
        self.y = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_y(&mut self) -> &mut Fr {
        if self.y.is_none() {
            self.y.set_default();
        }
        self.y.as_mut().unwrap()
    }

    // Take field
    pub fn take_y(&mut self) -> Fr {
        self.y.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_y(&self) -> &Fr {
        self.y.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // .protobuf.pb.Fr z = 12;

    pub fn clear_z(&mut self) {
        self.z.clear();
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: Fr) {
        self.z = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_z(&mut self) -> &mut Fr {
        if self.z.is_none() {
            self.z.set_default();
        }
        self.z.as_mut().unwrap()
    }

    // Take field
    pub fn take_z(&mut self) -> Fr {
        self.z.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_z(&self) -> &Fr {
        self.z.as_ref().unwrap_or_else(|| Fr::default_instance())
    }
}

impl ::protobuf::Message for BulletProof {
    fn is_initialized(&self) -> bool {
        for v in &self.vcmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t1_cmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t2_cmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tau_x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mu {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.t_hat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dot_proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.x {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.y {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.z {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vcmt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acmt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scmt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t1_cmt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t2_cmt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tau_x)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mu)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t_hat)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dot_proof)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.x)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.y)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.z)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.vcmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.acmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t1_cmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t2_cmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tau_x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mu.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.t_hat.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dot_proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.x.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.y.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.z.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.vcmt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.acmt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scmt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t1_cmt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t2_cmt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tau_x.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mu.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.t_hat.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dot_proof.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.x.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.y.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.z.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BulletProof {
        BulletProof::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "vcmt",
                    |m: &BulletProof| { &m.vcmt },
                    |m: &mut BulletProof| { &mut m.vcmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "acmt",
                    |m: &BulletProof| { &m.acmt },
                    |m: &mut BulletProof| { &mut m.acmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "scmt",
                    |m: &BulletProof| { &m.scmt },
                    |m: &mut BulletProof| { &mut m.scmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "t1_cmt",
                    |m: &BulletProof| { &m.t1_cmt },
                    |m: &mut BulletProof| { &mut m.t1_cmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pt>>(
                    "t2_cmt",
                    |m: &BulletProof| { &m.t2_cmt },
                    |m: &mut BulletProof| { &mut m.t2_cmt },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "tau_x",
                    |m: &BulletProof| { &m.tau_x },
                    |m: &mut BulletProof| { &mut m.tau_x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "mu",
                    |m: &BulletProof| { &m.mu },
                    |m: &mut BulletProof| { &mut m.mu },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "t_hat",
                    |m: &BulletProof| { &m.t_hat },
                    |m: &mut BulletProof| { &mut m.t_hat },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DotProof>>(
                    "dot_proof",
                    |m: &BulletProof| { &m.dot_proof },
                    |m: &mut BulletProof| { &mut m.dot_proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "x",
                    |m: &BulletProof| { &m.x },
                    |m: &mut BulletProof| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "y",
                    |m: &BulletProof| { &m.y },
                    |m: &mut BulletProof| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "z",
                    |m: &BulletProof| { &m.z },
                    |m: &mut BulletProof| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BulletProof>(
                    "BulletProof",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BulletProof {
        static mut instance: ::protobuf::lazy::Lazy<BulletProof> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BulletProof,
        };
        unsafe {
            instance.get(BulletProof::new)
        }
    }
}

impl ::protobuf::Clear for BulletProof {
    fn clear(&mut self) {
        self.clear_vcmt();
        self.clear_acmt();
        self.clear_scmt();
        self.clear_t1_cmt();
        self.clear_t2_cmt();
        self.clear_tau_x();
        self.clear_mu();
        self.clear_t_hat();
        self.clear_dot_proof();
        self.clear_x();
        self.clear_y();
        self.clear_z();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BulletProof {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BulletProof {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Output {
    // message fields
    pub recipient: ::protobuf::SingularPtrField<PublicKey>,
    pub proof: ::protobuf::SingularPtrField<BulletProof>,
    pub payload: ::protobuf::SingularPtrField<EncryptedPayload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Output {
    pub fn new() -> Output {
        ::std::default::Default::default()
    }

    // .protobuf.pb.PublicKey recipient = 1;

    pub fn clear_recipient(&mut self) {
        self.recipient.clear();
    }

    pub fn has_recipient(&self) -> bool {
        self.recipient.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient(&mut self, v: PublicKey) {
        self.recipient = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recipient(&mut self) -> &mut PublicKey {
        if self.recipient.is_none() {
            self.recipient.set_default();
        }
        self.recipient.as_mut().unwrap()
    }

    // Take field
    pub fn take_recipient(&mut self) -> PublicKey {
        self.recipient.take().unwrap_or_else(|| PublicKey::new())
    }

    pub fn get_recipient(&self) -> &PublicKey {
        self.recipient.as_ref().unwrap_or_else(|| PublicKey::default_instance())
    }

    // .protobuf.pb.BulletProof proof = 2;

    pub fn clear_proof(&mut self) {
        self.proof.clear();
    }

    pub fn has_proof(&self) -> bool {
        self.proof.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof(&mut self, v: BulletProof) {
        self.proof = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof(&mut self) -> &mut BulletProof {
        if self.proof.is_none() {
            self.proof.set_default();
        }
        self.proof.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof(&mut self) -> BulletProof {
        self.proof.take().unwrap_or_else(|| BulletProof::new())
    }

    pub fn get_proof(&self) -> &BulletProof {
        self.proof.as_ref().unwrap_or_else(|| BulletProof::default_instance())
    }

    // .protobuf.pb.EncryptedPayload payload = 3;

    pub fn clear_payload(&mut self) {
        self.payload.clear();
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: EncryptedPayload) {
        self.payload = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut EncryptedPayload {
        if self.payload.is_none() {
            self.payload.set_default();
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> EncryptedPayload {
        self.payload.take().unwrap_or_else(|| EncryptedPayload::new())
    }

    pub fn get_payload(&self) -> &EncryptedPayload {
        self.payload.as_ref().unwrap_or_else(|| EncryptedPayload::default_instance())
    }
}

impl ::protobuf::Message for Output {
    fn is_initialized(&self) -> bool {
        for v in &self.recipient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.payload {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.recipient)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.payload)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.recipient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.proof.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.recipient.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.proof.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.payload.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Output {
        Output::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PublicKey>>(
                    "recipient",
                    |m: &Output| { &m.recipient },
                    |m: &mut Output| { &mut m.recipient },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BulletProof>>(
                    "proof",
                    |m: &Output| { &m.proof },
                    |m: &mut Output| { &mut m.proof },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncryptedPayload>>(
                    "payload",
                    |m: &Output| { &m.payload },
                    |m: &mut Output| { &mut m.payload },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Output>(
                    "Output",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Output {
        static mut instance: ::protobuf::lazy::Lazy<Output> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Output,
        };
        unsafe {
            instance.get(Output::new)
        }
    }
}

impl ::protobuf::Clear for Output {
    fn clear(&mut self) {
        self.clear_recipient();
        self.clear_proof();
        self.clear_payload();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Output {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Output {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Transaction {
    // message fields
    pub txins: ::protobuf::RepeatedField<Hash>,
    pub txouts: ::protobuf::RepeatedField<Output>,
    pub gamma: ::protobuf::SingularPtrField<Fr>,
    pub fee: i64,
    pub sig: ::protobuf::SingularPtrField<SchnorrSig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // repeated .protobuf.pb.Hash txins = 1;

    pub fn clear_txins(&mut self) {
        self.txins.clear();
    }

    // Param is passed by value, moved
    pub fn set_txins(&mut self, v: ::protobuf::RepeatedField<Hash>) {
        self.txins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txins(&mut self) -> &mut ::protobuf::RepeatedField<Hash> {
        &mut self.txins
    }

    // Take field
    pub fn take_txins(&mut self) -> ::protobuf::RepeatedField<Hash> {
        ::std::mem::replace(&mut self.txins, ::protobuf::RepeatedField::new())
    }

    pub fn get_txins(&self) -> &[Hash] {
        &self.txins
    }

    // repeated .protobuf.pb.Output txouts = 2;

    pub fn clear_txouts(&mut self) {
        self.txouts.clear();
    }

    // Param is passed by value, moved
    pub fn set_txouts(&mut self, v: ::protobuf::RepeatedField<Output>) {
        self.txouts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txouts(&mut self) -> &mut ::protobuf::RepeatedField<Output> {
        &mut self.txouts
    }

    // Take field
    pub fn take_txouts(&mut self) -> ::protobuf::RepeatedField<Output> {
        ::std::mem::replace(&mut self.txouts, ::protobuf::RepeatedField::new())
    }

    pub fn get_txouts(&self) -> &[Output] {
        &self.txouts
    }

    // .protobuf.pb.Fr gamma = 3;

    pub fn clear_gamma(&mut self) {
        self.gamma.clear();
    }

    pub fn has_gamma(&self) -> bool {
        self.gamma.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma(&mut self, v: Fr) {
        self.gamma = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma(&mut self) -> &mut Fr {
        if self.gamma.is_none() {
            self.gamma.set_default();
        }
        self.gamma.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma(&mut self) -> Fr {
        self.gamma.take().unwrap_or_else(|| Fr::new())
    }

    pub fn get_gamma(&self) -> &Fr {
        self.gamma.as_ref().unwrap_or_else(|| Fr::default_instance())
    }

    // int64 fee = 4;

    pub fn clear_fee(&mut self) {
        self.fee = 0;
    }

    // Param is passed by value, moved
    pub fn set_fee(&mut self, v: i64) {
        self.fee = v;
    }

    pub fn get_fee(&self) -> i64 {
        self.fee
    }

    // .protobuf.pb.SchnorrSig sig = 5;

    pub fn clear_sig(&mut self) {
        self.sig.clear();
    }

    pub fn has_sig(&self) -> bool {
        self.sig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig(&mut self, v: SchnorrSig) {
        self.sig = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig(&mut self) -> &mut SchnorrSig {
        if self.sig.is_none() {
            self.sig.set_default();
        }
        self.sig.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig(&mut self) -> SchnorrSig {
        self.sig.take().unwrap_or_else(|| SchnorrSig::new())
    }

    pub fn get_sig(&self) -> &SchnorrSig {
        self.sig.as_ref().unwrap_or_else(|| SchnorrSig::default_instance())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.txins {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.txouts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gamma {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.txouts)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gamma)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fee = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sig)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.txins {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.txouts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.gamma.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fee != 0 {
            my_size += ::protobuf::rt::value_size(4, self.fee, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.txins {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.txouts {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.gamma.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fee != 0 {
            os.write_int64(4, self.fee)?;
        }
        if let Some(ref v) = self.sig.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Hash>>(
                    "txins",
                    |m: &Transaction| { &m.txins },
                    |m: &mut Transaction| { &mut m.txins },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Output>>(
                    "txouts",
                    |m: &Transaction| { &m.txouts },
                    |m: &mut Transaction| { &mut m.txouts },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Fr>>(
                    "gamma",
                    |m: &Transaction| { &m.gamma },
                    |m: &mut Transaction| { &mut m.gamma },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fee",
                    |m: &Transaction| { &m.fee },
                    |m: &mut Transaction| { &mut m.fee },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchnorrSig>>(
                    "sig",
                    |m: &Transaction| { &m.sig },
                    |m: &mut Transaction| { &mut m.sig },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Transaction,
        };
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.clear_txins();
        self.clear_txouts();
        self.clear_gamma();
        self.clear_fee();
        self.clear_sig();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nnode.proto\x12\x0bprotobuf.pb\"\x16\n\x02Pt\x12\x10\n\x04data\x18\
    \x01\x20\x01(\x0cB\x02\x18\0\"\x16\n\x02Fr\x12\x10\n\x04data\x18\x01\x20\
    \x01(\x0cB\x02\x18\0\"\x18\n\x04Hash\x12\x10\n\x04data\x18\x01\x20\x01(\
    \x0cB\x02\x18\0\"/\n\tPublicKey\x12\"\n\x05point\x18\x01\x20\x01(\x0b2\
    \x0f.protobuf.pb.PtB\x02\x18\0\"L\n\nSchnorrSig\x12\x1e\n\x01u\x18\x01\
    \x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01K\x18\x02\x20\
    \x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\"h\n\x10EncryptedPayload\x12!\n\
    \x04apkg\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x1f\n\
    \x02ag\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x10\n\x04\
    ctxt\x18\x03\x20\x01(\x0cB\x02\x18\0\"d\n\x02LR\x12\x1e\n\x01x\x18\x01\
    \x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01l\x18\x02\x20\
    \x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x1e\n\x01r\x18\x03\x20\x01(\
    \x0b2\x0f.protobuf.pb.PtB\x02\x18\0\"\xb0\x01\n\x08DotProof\x12\x1e\n\
    \x01u\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12!\n\x04pcmt\
    \x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\x1e\n\x01a\x18\
    \x03\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01b\x18\x04\
    \x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12!\n\x04xlrs\x18\x05\x20\
    \x03(\x0b2\x0f.protobuf.pb.LRB\x02\x18\0\"\xb7\x03\n\x0bBulletProof\x12!\
    \n\x04vcmt\x18\x01\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12!\n\
    \x04acmt\x18\x02\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12!\n\x04s\
    cmt\x18\x03\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12#\n\x06t1_cmt\
    \x18\x04\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12#\n\x06t2_cmt\
    \x18\x05\x20\x01(\x0b2\x0f.protobuf.pb.PtB\x02\x18\0\x12\"\n\x05tau_x\
    \x18\x06\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1f\n\x02mu\x18\
    \x07\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\"\n\x05t_hat\x18\
    \x08\x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12,\n\tdot_proof\x18\t\
    \x20\x01(\x0b2\x15.protobuf.pb.DotProofB\x02\x18\0\x12\x1e\n\x01x\x18\n\
    \x20\x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01y\x18\x0b\x20\
    \x01(\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x1e\n\x01z\x18\x0c\x20\x01(\
    \x0b2\x0f.protobuf.pb.FrB\x02\x18\0\"\x98\x01\n\x06Output\x12-\n\trecipi\
    ent\x18\x01\x20\x01(\x0b2\x16.protobuf.pb.PublicKeyB\x02\x18\0\x12+\n\
    \x05proof\x18\x02\x20\x01(\x0b2\x18.protobuf.pb.BulletProofB\x02\x18\0\
    \x122\n\x07payload\x18\x03\x20\x01(\x0b2\x1d.protobuf.pb.EncryptedPayloa\
    dB\x02\x18\0\"\xbb\x01\n\x0bTransaction\x12$\n\x05txins\x18\x01\x20\x03(\
    \x0b2\x11.protobuf.pb.HashB\x02\x18\0\x12'\n\x06txouts\x18\x02\x20\x03(\
    \x0b2\x13.protobuf.pb.OutputB\x02\x18\0\x12\"\n\x05gamma\x18\x03\x20\x01\
    (\x0b2\x0f.protobuf.pb.FrB\x02\x18\0\x12\x0f\n\x03fee\x18\x04\x20\x01(\
    \x03B\x02\x18\0\x12(\n\x03sig\x18\x05\x20\x01(\x0b2\x17.protobuf.pb.Schn\
    orrSigB\x02\x18\0B\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
